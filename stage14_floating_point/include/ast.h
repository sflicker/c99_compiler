#ifndef AST_H
#define AST_H

#include <stdbool.h>

#include "token.h"
#include "c_type.h"
#include "util.h"
#include "list_util.h"
#include "ast_lists.h"
#include "ast_list.h"

typedef enum {
    BINOP_ADD,
    BINOP_SUB,
    BINOP_MUL,
    BINOP_DIV,
    BINOP_MOD,
    BINOP_EQ,
    BINOP_NE,
    BINOP_GT,
    BINOP_GE,
    BINOP_LT,
    BINOP_LE,
    BINOP_LOGICAL_OR,
    BINOP_LOGICAL_AND,
    BINOP_UNASSIGNED_OP,
    BINOP_ASSIGNMENT,
    BINOP_COMPOUND_ADD_ASSIGN,
    BINOP_COMPOUND_SUB_ASSIGN
} BinaryOperator;

typedef struct {
    ASTNode * lhs;
    ASTNode * rhs;
    BinaryOperator op;
    CType * common_type;
} BinaryExpr;

typedef enum {
    UNARY_NEGATE,         // -a
    UNARY_PLUS,           // +a    usually this is just a noop
    UNARY_NOT,            // !a
    UNARY_PRE_INC,        // ++a
    UNARY_PRE_DEC,        // --a
    UNARY_POST_INC,       // a++
    UNARY_POST_DEC,       // a--
    UNARY_DEREF,          // *a
    UNARY_ADDRESS,        // &a
    UNARY_UNASSIGNED_OP   // op is not assigned. 
} UnaryOperator;

typedef struct {
    ASTNode * operand;
    UnaryOperator op;
} UnaryExpr;

typedef struct {
    char * value;
    int length;
    char * label;
} StringLiteral;

typedef struct {
    float value;
    char * label;
} FloatLiteral;

typedef struct {
    double value;
    char * label;
} DoubleLiteral;

typedef enum {
    AST_RETURN_STMT,
    AST_IF_STMT,
    AST_WHILE_STMT,
    AST_FOR_STMT,
    AST_DO_WHILE_STMT,
    AST_LABELED_STMT,
    AST_CASE_STMT,
    AST_DEFAULT_STMT,
    AST_GOTO_STMT,
    AST_SWITCH_STMT,
    AST_BREAK_STMT,
    AST_CONTINUE_STMT,
    AST_INT_LITERAL,
    AST_FLOAT_LITERAL,
    AST_DOUBLE_LITERAL,
    AST_FUNCTION_DECL,
    AST_FUNCTION_DEF,
    AST_FUNCTION_CALL_EXPR,
    AST_TRANSLATION_UNIT,
    AST_BLOCK_STMT,
    AST_EXPRESSION_STMT,
    AST_DECLARATION_STMT,
    AST_VAR_DECL,
    AST_VAR_REF_EXPR,
    AST_BINARY_EXPR,
    AST_UNARY_EXPR,
    AST_CAST_EXPR,
    AST_ARRAY_ACCESS,
    AST_INITIALIZER_LIST,
    AST_STRING_LITERAL,
    AST_ASSERT_EXTENSION_STATEMENT,
    AST_PRINT_EXTENSION_STATEMENT
} ASTNodeType;

typedef struct ASTNode {
    Symbol * symbol;
    ASTNodeType type;
    CType * ctype;
    union {
        int int_value;
        FloatLiteral float_literal;
        DoubleLiteral double_literal;
        StringLiteral string_literal;

        BinaryExpr binary;
        UnaryExpr unary;

        struct {
            ASTNode_list * functions;
            ASTNode_list * globals;
            ASTNode_list * string_literals;
            ASTNode_list * float_literals;
            ASTNode_list * double_literals;
            int count;
        } translation_unit;

        struct {
            char* name;
            ASTNode_list * param_list;
            CType * func_type;
            int param_count;
            // ASTNode* body;
            // bool declaration_only;
            int size;
        } function_decl;

        struct {
            char* name;
            ASTNode_list * param_list;
            CType * func_type;
            int param_count;
            ASTNode* body;
//            bool declaration_only;
            int size;
        } function_def;

        struct {
            char * name;
            ASTNode_list * arg_list;
            int arg_count;
        } function_call;

        struct {
            char* name;
            struct ASTNode * init_expr; // NULL if no initializer
//            CType * full_type;
            bool is_param;
            bool is_global;
        } var_decl;

        struct {
            char * name;
        } var_ref;

        struct {
            ASTNode * base;
            ASTNode * index;
        } array_access;

        struct {
            ASTNode_list * statements;
            bool introduce_scope;
            int count;
        } block;

        struct {
            struct ASTNode * expr;
        } return_stmt;

        struct {
            ASTNode * cond;
            ASTNode * then_stmt;
            ASTNode * else_stmt;
        } if_stmt;

        struct {
            ASTNode * cond;
            ASTNode * body;
        } while_stmt;

        struct {
            ASTNode * init_expr;
            ASTNode * cond_expr;
            ASTNode * update_expr;
            ASTNode * body;
        } for_stmt;

        struct {
            ASTNode * expr;
        } expr_stmt;

        struct {
            char * label;
            ASTNode * stmt;
        } labeled_stmt;

        struct {
            ASTNode * constExpression;
            ASTNode * stmt;
            const char * label;            // maybe generated by compiler
        } case_stmt;

        struct {
            ASTNode * stmt;
            const char * label;             // maybe gneerated by compiler
        } default_stmt;

        struct {
            char * label;
        } goto_stmt;

        struct {
            ASTNode * body;
            ASTNode * expr;
        } do_while_stmt;

        struct {
            ASTNode * expr;
            ASTNode * stmt;
        } switch_stmt;

        struct {
            CType * target_type;
            ASTNode * expr;
        } cast_expr;

        struct {
            ASTNode_list * items;
        } initializer_list;

        struct {
            CType * declaration_type;
            ASTNode_list * init_declarator_list;
        } declaration;
    };
} ASTNode;

ASTNode * create_ast();
void free_ast(ASTNode * node);

BinaryOperator get_binary_operator_from_tok(Token * tok);
const char * get_binary_op_name(BinaryOperator op);
const char * get_unary_op_name(UnaryOperator op);
bool ast_equal(ASTNode * a, ASTNode * b);
const char * get_ast_node_name(ASTNode * node);
ASTNode_list * create_node_list();
void flatten_list(ASTNode_list * list, ASTNode_list * flattened_list);
int get_total_nested_array_elements(ASTNode * node);
int get_array_base_element_size(ASTNode * node);

bool is_assignment(ASTNode * node);
bool is_comparison_op(BinaryOperator op);

#endif
